### 기본정보

| TITLE      | VALUE                                               |
| ---------- | --------------------------------------------------- |
| **일시**     | 2026.02.05                                          |
| **번호**     | 9063                                                |
| **아이디어**   | 모든 점의 X, Y 좌표에 대해 최소값과 최대값을 추적하여<br>외접 직사각형의 넓이를 계산 |
| **시간복잡도**  | **O(N)**                                            |
| **사용 API** | `std::cin`, `std::cout`, `abs`                      |
| **경과시간**   | 10분                                                 |
| **결과**     | PASS                                                |
| 재풀이여부      | O                                                   |

---
### 메모

- 문제의 핵심은 **모든 점을 포함하는 최소 직사각형의 넓이 계산**
    
- 각 점을 개별적으로 저장할 필요 없음
    
    - X 좌표: `MinX`, `MaxX`
    - Y 좌표: `MinY`, `MaxY`
        
- 첫 입력값을 기준으로 최소·최대값 초기화 후 갱신
    
- 최종 넓이 공식
    
    `|MaxX - MinX| × |MaxY - MinY|`
    
- 점이 1개인 경우
    
    - 가로 또는 세로 길이가 0
    - 결과는 0 → 문제 조건상 정상
  
---
### GPT 피드백

- 문제를 **외접 직사각형(Bounding Box)** 문제로 정확히 해석함
    
- 불필요한 자료구조 없이 최소·최대 추적만 사용한 점이 적절
    
- 첫 입력에서 초기값을 설정하는 방식은 안전하고 명확함
    
- 좌표 범위를 고려하여 넓이를 `long long`으로 계산한 점도 적절
    
- 이 문제는 기하 문제가 아니라 **최소/최대 누적 갱신 패턴을 확인하는 문제**

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <climits>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    int N;
    std::cin >> N;

    int minX = INT_MAX, maxX = INT_MIN;
    int minY = INT_MAX, maxY = INT_MIN;

    for (int i = 0; i < N; ++i)
    {
        int x, y;
        std::cin >> x >> y;

        minX = std::min(minX, x);
        maxX = std::max(maxX, x);
        minY = std::min(minY, y);
        maxY = std::max(maxY, y);
    }

    long long area = 1LL * (maxX - minX) * (maxY - minY);
    std::cout << area;
    return 0;
}
```

---
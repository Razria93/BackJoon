### 기본정보

| TITLE      | VALUE                                                                                              |
| ---------- | -------------------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.05                                                                                         |
| **번호**     | 3009                                                                                               |
| **아이디어**   | 좌표를 X와 Y 요소로 분리하여 인식하고,<br>해당 요소가 등장한 적이 있을 경우 toggle값을 변경,<br>해당 요소가 등장한 적이 없을 경우 해당 값을 비교군으로 저장함 |
| **시간복잡도**  | **O(1) (입력 크기가 고정이기 때문)**                                                                          |
| **사용 API** | `std::cin`, `std::cout`                                                                            |
| **경과시간**   | 30분                                                                                                |
| **결과**     | PASS                                                                                               |
| 재풀이여부      | O                                                                                                  |

---
### 메모

- 문제를 풀긴 하였으나 너무 원초적인 방법임
	- 가독성이 떨어지고, 
	- 좌표의 숫자가 조금만이라도 늘어나면 관리가 힘들어지며,
	- 무엇보다 좌표가 0과 음수범위까지 포함하게 되면 초기값을 설정할 수 없어 문제가 되는 방식

- 핵심은 좌표를 독립적인 요소로 인지하고 한번만 등장한 값을 찾는 것
	- 이러한 문제를 풀기위해서는 `XOR`로 풀이를 접근하는 것이 가장 정석임

### 참고자료
**XOR**
```cpp
// XOR 연산자의 형태
int c = a ^ b;

// XOR의 성질
x ^ x == 0 // 자기자신과의 XOR은 0
x ^ 0 == x // 0과의 XOR은 자기자신
a ^ b == b ^ a // 교환법칙 성립 ([같은레벨 내] 처리순서 상관없음)
a ^ (b ^ c) == (a ^ b) ^ c // 결합법칙 성립 ([전체레벨 내] 처리순서 상관없음)

// XOR의 응용
// 홀수번 등장하는 값 찾기
x ^ x = 0
x ^ x ^ x = x
x ^ x ^ x ^ x = 0
```

- `XOR`은 `비트 단위 연산자`로 **비트 단위의 상태값을 반전시키는 연산자**임
	- 특정 수를 표현할 때 필요한 비트라는 버튼을 `ON/OFF` 하는 방식
	- A라는 패턴으로 눌렀던 것을 A라는 패턴으로 한번 더 누르면 A를 두번 입력했던 사실 자체가 사라짐
	- 그렇기 때문에 짝수로 누를 경우 해당 사실(행위)는 없었던 것으로 간주됨
	- 또한 값 자체를 저장하는 것이 아닌 비트별로 `눌림(ON)/안눌림(OFF)`이라는 상태로 저장되는 것이기 때문에 처리 순서가 상관이 없는 것

- 해당 방식은 `홀수 번 등장하는 하나의 다른 수`를 찾는데 사용함
	- 해당 방식은 각 수가 몇 번 등장했는지는 알 수 없으며, 홀수 번 등장하는 수가 2개 이상이면 상태값이 혼재되므로 사용할 수 없음
  
---
### GPT 피드백

- 문제의 논리는 정확했으나 구현이 과도하게 복잡함
    
- 상태 플래그 기반 구현은 실수 가능성이 높음
    
- XOR을 쓰면 코드 길이와 버그 가능성이 모두 감소
    
- 3009는 **XOR 사고를 연습하는 대표 문제**

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    int x, y;
    int rx = 0, ry = 0;

    for (int i = 0; i < 3; ++i)
    {
        std::cin >> x >> y;
        rx ^= x;
        ry ^= y;
    }

    std::cout << rx << ' ' << ry;
    return 0;
}
```

---
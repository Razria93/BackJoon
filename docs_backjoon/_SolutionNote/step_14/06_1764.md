### 기본정보

| TITLE      | VALUE                                                                                                          |
| ---------- | -------------------------------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.11                                                                                                     |
| **번호**     | 1764                                                                                                           |
| **아이디어**   | N개를 `set<string>`에 저장<br>M개를 입력받으며 `N.find`로 N과 M의 교집합을 `vector<string>`에 수집<br>수집된 `vector`를 정렬한 뒤 개수와 이름을 출력 |
| **시간복잡도**  | 삽입 O(N log N) + 조회 O(M log N) + 정렬 O(K log K)                                                                  |
| **사용 API** | `std::set`, `insert`, `find`, <br>`std::vector`, `push_back`,<br>`std::sort`                                   |
| **경과시간**   | 15분                                                                                                            |
| **결과**     | PASS                                                                                                           |
| 재풀이여부      | O                                                                                                              |

---
### 메모

- 아이디어와 방향성은 유효했으나 자료구조 선택이 살짝 아쉬웠던 문제
	- `set`은 정렬 특성이 있는데 이릉 활용하지 않고 `vector + sort` 를 하는 순간 `set` 자료구조의 정렬 특성은 쓸모가 없어짐
  
- 따라서 다음과 같은 자료구조와 알고리즘을 선택하는 것이 합리적임
	1. `unordered_set + vector + sort` 조합으로 `set`과 `vector`의 입력은 O(1)로 받되 `sort`를 사용하여 한번에 정렬하는 방법
	2. `unordered_set` + `set` 구조로 입력과 동시에 정렬을 하는 방법
  
---
### GPT 피드백

- **정확성**
    
    - 교집합 추출 로직이 요구사항과 일치함
        
    - 출력 형식(개수 먼저, 이후 이름 오름차순)도 맞는 형태
        
- **개선 포인트(선택)**
    
    1. `set` 자체가 이미 정렬 컨테이너라 “교집합도 정렬된 상태로 관리”하려면 결과도 `set`에 넣는 방식이 가능
        
        - 현재는 `vector`로 모은 뒤 정렬하므로 문제는 없지만, K가 커지면 중복 정렬 비용이 생김
            
    2. `for (std::string factor : vector)`는 문자열 복사가 발생
        
        - `for (const std::string& factor : vector)`가 더 정석
            
    3. 자료구조 선택 대안
        
        - `unordered_set`으로 평균 속도를 더 끌어올린 뒤 결과만 `vector`로 정렬하는 방식도 흔함(평균 O(N+M) + O(K log K))

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <unordered_set>
#include <vector>
#include <string>
#include <algorithm>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    int N, M;
    std::cin >> N >> M;

    std::unordered_set<std::string> s;
    s.reserve(N);

    for (int i = 0; i < N; ++i)
    {
        std::string x;
        std::cin >> x;
        s.insert(x);
    }

    std::vector<std::string> result;
    result.reserve(std::min(N, M));

    for (int i = 0; i < M; ++i)
    {
        std::string x;
        std::cin >> x;

        if (s.find(x) != s.end())
        {
            result.push_back(x);
        }
    }

    std::sort(result.begin(), result.end());

    std::cout << result.size() << '\n';
    for (const auto& name : result)
    {
        std::cout << name << '\n';
    }

    return 0;
}
```

---
### 기본정보

| TITLE      | VALUE                                                                                                                                                                                                |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.11                                                                                                                                                                                           |
| **번호**     | 1620                                                                                                                                                                                                 |
| **아이디어**   | 포켓몬 이름↔번호를 모두 빠르게 찾기 위해 `unordered_map`을 2개 운용<br> - 번호→이름: `unordered_map<int, string>`<br> - 이름→번호: `unordered_map<string, int>`<br> <br> 질의 문자열이 숫자로 시작하면 `stoi`로 번호 변환 후 번호맵 조회, <br> 아니면 이름맵 조회 |
| **시간복잡도**  | 평균 O(N + M) (해시 기반 기대값)질의에서 `stoi`는 문자열 길이 L에 대해 O(L)                                                                                                                                                |
| **사용 API** | `std::unordered_map`, `reserve`, `operator[]`, `std::stoi`                                                                                                                                           |
| **경과시간**   | 40분                                                                                                                                                                                                  |
| **결과**     | PASS                                                                                                                                                                                                 |
| 재풀이여부      | O                                                                                                                                                                                                    |

---
### 메모

- 질의의 타입을 구분하는데 필요한 `std::stoi`의 존재를 알지 못해 시간이 상당 부분 소요됨

- 더 깔끔한 방식과 더 효율적인 방법이 있으니 재풀이 요망
  
---
### GPT 피드백

#### **정확성**

- 문제 요구(번호↔이름 상호 조회)를 만족하는 전형적인 정답 구조
	
- 숫자/문자 분기로 질의 타입을 판별하는 방식도 이 문제 조건에선 유효

#### 개선 포인트

1. **삽입은 `operator[]`보다 `emplace`/`insert`가 더 정석**
```cpp
// insert: 키가 없으면 생성 후 삽입 / 있으면 X
map_num.insert({i, X}); 
map_name.insert({X, i});

// emplace: 키가 없으면 생성 후 삽입 / 있으면 대입
map_num.emplace(i, X); 
map_name.emplace(X, i);
```

2. **숫자 판별을 더 엄밀히 하려면 전체가 숫자인지 검사**
```cpp
// string 전체가 숫자인지 검사
const bool isNumber = std::all_of(q.begin(), q.end(),
	[](unsigned char c) 
	{
	 return std::isdigit(c) != 0; 
	});
	
// string이 숫자일 경우 숫자로 변환 (string to int)
if (isNumber)
{
	int num = std::stoi(q);
}
```

##### `std::all_of`
```cpp
bool answer = std::all_of(begin, end, predicate);
```

- `predicate(x)`가 범위의 모든 원소에 대해 `true`면 `true`
- 하나라도 `false`면 즉시 `false`
  
##### `std::isdigit`
```cpp
[](unsigned char c) { return std::isdigit(c) != 0; }
```

- `std::isdigit(c)`는 문자 `c`가 숫자 문자인지를 검사 
- 숫자면 0이 아닌 값 (`true`) / 아니면 0을 반환 (`false`)

**람다함수가 위의 형태인 이유**
- `std::isdigit`는 인자로 **unsigned char로 표현 가능한 값 또는 EOF**를 요구함
- `char`가 signed인 환경에서 음수 값이 들어가면 **UB(정의되지 않은 동작)** 가능성이 있으므로 `std::of` 에서 조건문을 체크하기 위해 조건문에 인수로 입력하는 값을 **unsigned char** 로 받아서 **UB** 를 피하기 위함

##### `std::stoi`
```cpp
std::stoi(s);
```

- `string to int`의 약어로 `string` 값을 `int`로 변환해주는 API
	- **stoi** = string to int
	- **stof** = string to float
	- **stol** = string to long
	- **stod** = string to double

- 해당 API를 안쓰고 바꾸고 싶을 경우
	1. `std::string S`
	2. `S.c_str()` : `char*` 반환
	3. `std::atoi()` : `ASCII to int`. `C style` 문자열을 받아서 `int`형으로 변환

##### vector + unordered_map VS unordered_map 2개

결론부터 말하면 **vector** + **unordered_map** 조합이 더 빠름
- `vector`와 `unordered_map` 모두 내부는 연속 메모리 구조로 되어 있음
- 그러나 해싱부터 몇단계를 거쳐야하는 `unordered_map` 과는 다르게 `vector`는 바로 접근할 수 있음
- 또한 버킷과 노드가 흩어져있을 수 있는 `unordered_map` 과는 다르게 `vector`는 데이터가 물리적으로 인접해 있어 **캐시 히트율**이 상대적으로 높음 (**메모리 지역성 우수**)

---
### 정석 코드 제안
#### 정석 코드 (vector + unordered_map)
```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
#include <string>
#include <algorithm>
#include <cctype>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    int N, M;
    std::cin >> N >> M;

    std::vector<std::string> numToName(N + 1);
    std::unordered_map<std::string, int> nameToNum;
    nameToNum.reserve(N);

    for (int i = 1; i <= N; ++i)
    {
        std::cin >> numToName[i];
        nameToNum.emplace(numToName[i], i);
    }

    for (int i = 0; i < M; ++i)
    {
        std::string q;
        std::cin >> q;

        const bool isNumber = std::all_of(q.begin(), q.end(),
            [](unsigned char c) { return std::isdigit(c) != 0; });

        if (isNumber)
        {
            int num = std::stoi(q);
            std::cout << numToName[num] << '\n';
        }
        else
        {
            std::cout << nameToNum.at(q) << '\n';
        }
    }

    return 0;
}
```

#### 정석 코드 (unordered_map 2개)
```cpp
#include <iostream>
#include <unordered_map>
#include <string>
#include <algorithm>
#include <cctype>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    int N, M;
    std::cin >> N >> M;

    std::unordered_map<int, std::string> numToName;
    std::unordered_map<std::string, int> nameToNum;
    numToName.reserve(N);
    nameToNum.reserve(N);

    for (int i = 1; i <= N; ++i)
    {
        std::string x;
        std::cin >> x;

        numToName.emplace(i, x);
        nameToNum.emplace(x, i);
    }

    for (int i = 0; i < M; ++i)
    {
        std::string q;
        std::cin >> q;

        const bool isNumber = !q.empty() &&
            std::all_of(q.begin(), q.end(), [](unsigned char c)
            {
                return std::isdigit(c) != 0;
            });

        if (isNumber)
        {
            int num = std::stoi(q);
            std::cout << numToName.at(num) << '\n';
        }
        else
        {
            std::cout << nameToNum.at(q) << '\n';
        }
    }

    return 0;
}

```

---
### 기본정보

| TITLE      | VALUE                                                                                                                                                                                                           |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.11                                                                                                                                                                                                      |
| **번호**     | 7785                                                                                                                                                                                                            |
| **아이디어**   | `enter`일 때 이름을 `unordered_set`에 추가하고 동시에 `vector`에도 누적<br>`leave`일 때는 `unordered_set`에서 제거<br>입력 처리 후 `vector`를 내림차순 정렬하고 `unique`로 중복 제거<br>`vector`에 남아있는 이름들을 `key`값으로 `set.find()`로 조회<br>유효할 경우 `key`값을 출력 |
| **시간복잡도**  | `unordered_set` 삽입/삭제/탐색 O(1)<br>`vector` 정렬 O(N log N) <br>`unique` O(N)<br><br>출력 시 `find` O(1)<br>전체 평균 O(N + E log E)                                                                                       |
| **사용 API** | `std::unordered_set`, `insert`, `erase`, `find`, <br>`std::vector`, `push_back`, `erase`<br>`std::sort`, `std::greater`, `std::unique`                                                                          |
| **경과시간**   | 30분                                                                                                                                                                                                             |
| **결과**     | PASS                                                                                                                                                                                                            |
| 재풀이여부      | O                                                                                                                                                                                                               |

---
### 메모

- 다음 요소를 알고 있지 못해서 굉장히 복잡하게 푼 문제
	- `unordered_set`과 `set` 의 차이
	- `for(factor : set)` 으로 `set`의 `factor`들을 순회할 수 있다는 점

- 위 요소를 인지한 상태에서 재풀이 요망

#### `unordered_set`과 `set` 의 차이

- **unordered_set**: 평균 O(1) 삽입/삭제/탐색, 대신 정렬 불가 → 마지막에 벡터로 옮겨 정렬
    
- **set**: 항상 정렬 유지(O(log n)) → 역순 반복자로 바로 내림차순 출력 가능
  
#### 순회

##### 1) for (factor : container) 형태

`for (const auto& name : s)`

`factor` 는 `name`으로 바로 사용 가능

##### 2) for (int i = 0; i < N; ++i) 형태

- `begin()` → 첫 원소
- `end()` → 마지막 다음(센티넬)
    
- `rbegin()` → **마지막 원소**
- `rend()` → **첫 원소의 이전(센티넬)**

`for (it = begin(); it != end(); ++it)`는 **앞에서 뒤로 순회**하라는 것
`for (it = rbegin(); it != rend(); ++it)`는 **뒤에서 앞으로 순회**하라는 것

`factor`는 `*it` 형태로 꺼낼 수 있음
  
---
### GPT 피드백

#### 핵심 문제점

##### 1) `vector`에 enter만 누적 → 정렬/unique로 중복 제거하는 방식은 불필요

- 문제 요구는 “최종적으로 회사에 남아있는 사람”만 출력입니다.
    
- 따라서 **중간 히스토리를 저장할 이유가 없습니다.**
    
- 현재 방식은 최악에 가깝게 **메모리 O(enter 횟수)** 를 잡아먹습니다. (N이 크면 손해)

##### 2) `unique`가 “중복 제거”를 완전하게 해주는 게 아님

- `unique`는 **연속된 중복만** 제거합니다.  
  
- 지금은 `sort`를 먼저 해서 연속 중복이 되므로 결과적으로 제거되긴 하지만, 이건 “정렬 후 unique”라는 **부수효과에 의존**하는 형태입니다.

##### 3) 지금 로직은 “마지막 상태”만 필요인데 “과거 enter 기록”을 유지합니다

- enter 후 leave, 다시 enter 같은 케이스가 있을 때도 결국 최종 상태만 의미가 있습니다.
    
- set 하나면 충분합니다.

#### 정석 풀이 구조

##### 1) `unordered_set<string>` 또는 `set<string>`에 현재 재직자 유지
- `enter`면 insert
- `leave`면 erase

##### 2) 전부 처리한 뒤, set 내용을 **내림차순으로 출력**
- `unordered_set`은 정렬이 안 되므로 **벡터로 옮겨 정렬**
- 또는 애초에 `std::set`을 써서 정렬 상태 유지(단, 시간은 O(log n))

---
### 정석 코드 제안
#### 정석 코드 (unordered_set + vector)
```cpp
#include <iostream>
#include <unordered_set>
#include <vector>
#include <string>
#include <algorithm>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    int N;
    std::cin >> N;

    std::unordered_set<std::string> s;
    s.reserve(N);

    for (int i = 0; i < N; ++i)
    {
        std::string name, log;
        std::cin >> name >> log;

        if (log == "enter") s.insert(name);
        else s.erase(name);
    }

    std::vector<std::string> v;
    v.reserve(s.size());
    for (const auto& name : s)
    {
        v.push_back(name);
    }

    std::sort(v.begin(), v.end(), std::greater<std::string>());

    for (const auto& name : v)
    {
        std::cout << name << '\n';
    }

    return 0;
}
```

#### 정석 코드 (set 단일)
```cpp
#include <iostream>
#include <set>
#include <string>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    int N;
    std::cin >> N;

    std::set<std::string> s;

    for (int i = 0; i < N; ++i)
    {
        std::string name, log;
        std::cin >> name >> log;

        if (log == "enter") s.insert(name);
        else s.erase(name);
    }

    for (auto it = s.rbegin(); it != s.rend(); ++it)
    {
        std::cout << *it << '\n';
    }

    return 0;
}
```



---
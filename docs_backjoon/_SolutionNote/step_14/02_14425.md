### 기본정보

| TITLE      | VALUE                                                                                                                      |
| ---------- | -------------------------------------------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.11                                                                                                                 |
| **번호**     | 14425                                                                                                                      |
| **아이디어**   | N개의 문자열을 `unordered_set<string>`에 저장 후,<br>M개의 문자열을 `find`로 조회하여 <br>집합에 포함된 개수를 카운트 (`++count`)<br>for문이 종료되면 `count`를 출력 |
| **시간복잡도**  | 평균 O(N + M) (해시 기반, 기대값) / 최악 O(N·M) 가능                                                                                    |
| **사용 API** | `std::unordered_set<std::string>`, `reserve`, `insert`, `find`, `end`                                                      |
| **경과시간**   | 5분                                                                                                                         |
| **결과**     | PASS                                                                                                                       |
| 재풀이여부      | X                                                                                                                          |

---
### 메모

- 
  
---
### GPT 피드백

- **정확성**
    
    - 요구사항(집합 S에 포함된 문자열 개수)을 정확히 구현함
        
    - `count`를 증가시키는 조건도 올바름
        
- **개선 포인트(선택)**
    
    - `find` 결과를 변수로 받지 않고 한 줄로도 가능
        
        - `if (set.find(X) != set.end()) ++count;`
            
    - 아주 미세한 최적화로는 삽입 시 `set.insert(std::move(X));`가 가능하나, 입력 직후라 체감은 거의 없음(대개 불필요)
        
    - 출력 마지막에 `'\n'`을 붙이면 포맷이 더 깔끔함(채점 영향은 보통 없음)

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <unordered_set>
#include <string>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    size_t N, M;
    std::cin >> N >> M;

    std::unordered_set<std::string> s;
    s.reserve(N);

    for (size_t i = 0; i < N; ++i)
    {
        std::string x;
        std::cin >> x;
        s.insert(x);
    }

    size_t count = 0;

    for (size_t i = 0; i < M; ++i)
    {
        std::string x;
        std::cin >> x;

        if (s.find(x) != s.end())
        {
            ++count;
        }
    }

    std::cout << count << '\n';
    return 0;
}
```

---
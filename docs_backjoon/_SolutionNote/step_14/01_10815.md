### 기본정보

| TITLE      | VALUE                                                                             |
| ---------- | --------------------------------------------------------------------------------- |
| **일시**     | 2026.02.11                                                                        |
| **번호**     | 10815                                                                             |
| **아이디어**   | `unordered_set`에 N개의 카드를 저장한 뒤,<br>M개의 질의 숫자에 대해 <br>`find`로 존재 여부를 O(1) 기대값으로 판정 |
| **시간복잡도**  | 평균 O(N + M) (해시 기반, 기대값) / 최악 O(N·M) 가능(충돌이 극단적인 경우)                              |
| **사용 API** | `std::unordered_set`, `insert`, `find`, `end`                                     |
| **경과시간**   | 20분                                                                               |
| **결과**     | PASS                                                                              |
| 재풀이여부      | O                                                                                 |

---
### 메모

- `두 숫자 카드에 같은 수가 적혀있는 경우는 없다`는 조건에 기반하여 중복값을 허용하지 않는 `std::unoredered_set` 기반으로 문제를 접근함
  
---
### GPT 피드백

- **좋은 점**
    
    - 문제 요구(존재 여부 판정)에 `unordered_set` 선택은 정석적인 접근
        
    - `find != end`로 존재 여부 판단 방식도 정확
        
- **개선 포인트**
    
    - `const auto& it = set.find(X);` → `auto it = ...` 또는 `if (set.find(X) != set.end())` 권장
        
        - 이터레이터는 보통 작은 값 타입이라 참조로 받을 이득이 없음
            
    - `set.reserve(N);`를 추가하면 리해시 빈도를 줄여 성능이 안정화될 수 있음(필수 아님)
        
    - 출력 포맷은 마지막 공백을 피하거나 마지막에 `'\n'`을 추가하는 습관 권장

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <unordered_set>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    size_t N;
    std::cin >> N;

    std::unordered_set<int> set;
    set.reserve(N); // 선택: 리해시 감소로 성능 안정화

    for (size_t i = 0; i < N; ++i)
    {
        int x;
        std::cin >> x;
        set.insert(x);
    }

    size_t M;
    std::cin >> M;

    for (size_t i = 0; i < M; ++i)
    {
        int x;
        std::cin >> x;

        std::cout << (set.find(x) != set.end());

        if (i + 1 < M) std::cout << ' ';
    }

    std::cout << '\n';
    return 0;
}
```

---
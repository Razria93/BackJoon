### 기본정보

| TITLE      | VALUE                                                                                                    |
| ---------- | -------------------------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.11                                                                                               |
| **번호**     | 11478                                                                                                    |
| **아이디어**   | 문자열의 모든 부분문자열 `s.substr(i, j)`를 생성해<br>`unordered_set<string>`에 삽입하여 중복을 제거하고,<br>최종 set 크기를 출력          |
| **시간복잡도**  | 부분문자열 개수는 O(n²)<br>각 `substr` 생성이 길이 O(j) 복사를 포함하므로 <br>전체는 대략 O(n³) 수준까지 커질 수 있음<br>(입력 길이에 따라 상수/편차 큼) |
| **사용 API** | `std::string::substr`, <br>`std::unordered_set<std::string>`, `insert`, `size`                           |
| **경과시간**   | 5분                                                                                                       |
| **결과**     | PASS                                                                                                     |
| 재풀이여부      | O                                                                                                        |
|            |                                                                                                          |

---
### 메모

- 풀이 자체는 쉬웠으나 `std::substr` API를 상기시키기 위해 재풀이를 제안함

- 또한 그래프의 아이디어를 기반으로 시간복잡도를 크게 줄이는 방법도 있음

- 다만 현재의 경험으로는 구현하기 어려우므로 넘어가고 추후 해당 방식을 기반으로 구현
  
---
### GPT 피드백

- **정확성**
    
    - 11478 요구(서로 다른 부분문자열 개수)를 정확히 구현함
        
- **주의/개선 포인트**
    
    1. 이 풀이는 구현은 단순하지만, `substr`가 매번 새 문자열을 **복사 생성**하므로 시간이 늘어날 수 있음
        
        - n이 커지면 O(n³)급으로 체감이 커질 수 있음
	
    2. 그래도 11478의 입력 길이는 보통 크지 않아(문제 제한 내) 통과하는 대표 풀이 중 하나임
	
    3. 성능을 더 챙기려면(심화):
        
        - `string_view`(C++17) + 해시 커스텀으로 복사 비용을 줄이거나
            
        - 접미사 배열/접미사 자동자(Suffix Automaton)로 O(n²) 또는 O(n)~O(n log n) 계열로 개선 가능
            
        - 다만 코테 정석으로는 현재 방식이 가장 흔한 “직관 풀이”에 해당

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <string>
#include <unordered_set>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    std::string s;
    std::cin >> s;

    std::unordered_set<std::string> st;
    // st.reserve(s.size() * s.size()); // 선택: 대략적인 상한 추정치(메모리 주의)

    for (size_t i = 0; i < s.size(); ++i)
    {
        for (size_t len = 1; len <= s.size() - i; ++len)
        {
            st.insert(s.substr(i, len));
        }
    }

    std::cout << st.size() << '\n';
    return 0;
}
```

---
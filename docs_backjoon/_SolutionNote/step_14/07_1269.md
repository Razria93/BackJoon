### 기본정보

| TITLE      | VALUE                                                                                                                                                                      |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.11                                                                                                                                                                 |
| **번호**     | 1269                                                                                                                                                                       |
| **아이디어**   | 집합 A의 원소 N개를 `unordered_set`에 저장 <br>집합 B의 원소 M개를 순회<br>- 이미 존재하면 삭제<br>- 없으면 삽입<br>하는 “토글(toggle)” 방식으로 **대칭 차집합(A △ B)** 을 유지<br>최종적으로 `set.size()`가 대칭 차집합의 크기이므로 이를 출력 |
| **시간복잡도**  | 평균 O(N + M) (해시 기반 기대값)                                                                                                                                                    |
| **사용 API** | `std::unordered_set`, `insert`, `find`, `erase`, `end`, `size`                                                                                                             |
| **경과시간**   | 5분                                                                                                                                                                         |
| **결과**     | PASS                                                                                                                                                                       |
| 재풀이여부      | X                                                                                                                                                                          |

---
### GPT 피드백

- **정확성**
    
    - 1269는 대칭 차집합의 원소 개수를 출력하는 문제라서, 토글 방식이 논리적으로 정확함
        
    - 최종 `set`이 곧 `A △ B`가 되고 `set.size()`가 답
        
- **개선 포인트**
	  
	1. `set.erase(*it)` 대신 `set.erase(it)`와 같이 이터레이터를 바로 넘길 수 있음
        - 불필요한 키 재전달 없이 “찾은 위치 삭제” 의도가 더 명확함
		
    2. 리해시 감소를 위해 `set.reserve(N + M)`도 선택지 (필수 아님)
  
---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <unordered_set>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    int N, M;
    std::cin >> N >> M;

    std::unordered_set<int> s;
    s.reserve(static_cast<size_t>(N) + static_cast<size_t>(M));

    for (int i = 0; i < N; ++i)
    {
        int x;
        std::cin >> x;
        s.insert(x);
    }

    for (int i = 0; i < M; ++i)
    {
        int x;
        std::cin >> x;

        auto it = s.find(x);
        if (it != s.end()) s.erase(it);
        else s.insert(x);
    }

    std::cout << s.size() << '\n';
    return 0;
}
```

---
### 기본정보

| TITLE      | VALUE                                                                                 |
| ---------- | ------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.02                                                                            |
| **번호**     | 2566                                                                                  |
| **아이디어**   | 9×9 행렬 입력을 행·열 인덱스 기반 이중 루프로 순회하면서, <br>입력 즉시 현재 최댓값과 위치(row, column)를 갱신하는 스트림 처리 방식 |
| **시간복잡도**  | O(9×9) = O(1)                                                                         |
| **사용 API** | `std::cin`, `std::cout`                                                               |
| **경과시간**   | -                                                                                     |
| **결과**     | PASS                                                                                  |
| 재풀이여부      | X                                                                                     |

---
### 메모

- 문제의도는 2차원 배열처럼 보이나 조건상 **행렬의 전체 데이터를 이후에 다시 사용할 필요가 없음**

- 따라서 2차원 배열에 값을 저장하지 않고 **입력과 동시에 최대값 비교 및 위치 기록**만 수행함

---
### GPT 피드백

- 본 풀이는 **2차원 배열 문제를 반드시 2차원 배열로 풀어야 한다는 고정관념에서 벗어난 풀이**
    
- “데이터를 저장해야 하는가?”라는 질문에 대해 이 문제에서는 **NO**라는 판단이 정확함
    
- 입력 → 비교 → 기록의 단일 패스 구조로, **불필요한 메모리 사용을 제거한 스트림 기반 정석 풀이**
    
- `target >= max` 조건을 사용함으로써 동일한 최댓값이 여러 개일 경우 **가장 마지막 위치**를 출력하는 문제 조건을 정확히 충족함
    
- 다만 일반화 관점에서는
    
    - 문제 크기가 커질 경우를 대비한 `int` vs `size_t` 타입 선택
        
    - 혹은 명시적인 2차원 배열 풀이도 함께 알고 있는 것이 바람직함

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int matrix[9][9];
    int maxValue = 0;
    int maxRow = 1;
    int maxCol = 1;

    for (int i = 0; i < 9; ++i)
    {
        for (int j = 0; j < 9; ++j)
        {
            std::cin >> matrix[i][j];

            if (matrix[i][j] >= maxValue)
            {
                maxValue = matrix[i][j];
                maxRow = i + 1;
                maxCol = j + 1;
            }
        }
    }

    std::cout << maxValue << '\n';
    std::cout << maxRow << ' ' << maxCol;

    return 0;
}

```

---
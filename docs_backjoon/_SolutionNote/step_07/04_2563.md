### 기본정보

| TITLE      | VALUE                                                                                                 |
| ---------- | ----------------------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.02                                                                                            |
| **번호**     | 2563                                                                                                  |
| **아이디어**   | 100×100 크기의 평면을 불리언 2차원 배열로 모델링하고, <br>각 색종이가 덮는 10×10 영역을 `true`로 마킹한 뒤 <br>전체 `true` 개수를 합산하여 면적 계산 |
| **시간복잡도**  | O(N × 10 × 10 + 100 × 100) ≈ O(1)                                                                     |
| **사용 API** | `std::cin`, `std::cout`                                                                               |
| **경과시간**   | 11분                                                                                                   |
| **결과**     | PASS                                                                                                  |
| 재풀이여부      | X                                                                                                     |

---
### 메모

- - 본 문제는 **좌표 공간 자체가 의미를 가지는 전형적인 격자(Grid) 문제**
    
- 모든 좌표는 항상 유효하며, 해당 칸이 덮였는지 여부(`true / false`)가 상태값이 됨
    
- 따라서 2차원 배열을 사용해 **면적을 직접 모델링**하는 방식이 자연스러움
    
- 색종이가 겹치는 경우에도 단순히 `true`로 덮어쓰기 때문에 해당 면적에 중복으로 처리가 들어간다하더라도 true에서 true로 바꾸는 것이기 때문에 별도의 충돌 처리나 중복 제거 로직이 필요 없음

---
### GPT 피드백

- - 이 문제는 색종이의 개수가 아니라 **덮인 면적**을 구하는 문제이므로, 개별 색종이를 관리하는 방식보다 **공간을 상태로 관리하는 방식**이 정석임
    
- `bool[100][100]` 배열은 문제의 개념 모델과 정확히 일치함
    
    - 좌표는 항상 존재
        
    - 값(`true / false`)이 상태를 의미
        
	- 색종이의 크기가 고정(10×10)이고, 전체 보드 크기도 작아 시간·메모리 측면에서 매우 안정적인 풀이함
    
- 이 문제는 이전에 다뤘던 10798과 달리 **없는 칸 개념이 존재하지 않는 문제**이므로, 문자열이나 가변 시퀀스보다 2차원 배열이 명확히 더 적합함

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    bool board[100][100] = {};

    int n;
    std::cin >> n;

    for (int k = 0; k < n; ++k)
    {
        int x, y;
        std::cin >> x >> y;

        for (int i = 0; i < 10; ++i)
            for (int j = 0; j < 10; ++j)
                board[x + i][y + j] = true;
    }

    int area = 0;
    for (int i = 0; i < 100; ++i)
        for (int j = 0; j < 100; ++j)
            if (board[i][j])
                ++area;

    std::cout << area;
    return 0;
}
```

---
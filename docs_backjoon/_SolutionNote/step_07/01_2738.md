### 기본정보

| TITLE      | VALUE                              |
| ---------- | ---------------------------------- |
| **일시**     | 2026.00.00                         |
| **번호**     |                                    |
| **아이디어**   | <br>                               |
| **시간복잡도**  |                                    |
| **사용 API** |                                    |
| **경과시간**   |                                    |
| **결과**     |                                    |
| 재풀이여부      |                                    |

---
### 메모

- 없음

---
### GPT 피드백

- 

---
### 정석 코드 제안
#### 정석 코드
```cpp
```

---### 기본정보

| TITLE      | VALUE                                                                                      |
| ---------- | ------------------------------------------------------------------------------------------ |
| **일시**     | 2026.02.02                                                                                 |
| **번호**     | 2738                                                                                       |
| **아이디어**   | N×M 크기의 2차원 행렬을 이중 포인터(`int**`) 기반으로 행 단위 동적 할당<br>하여 저장한 뒤, 두 번째 행렬 입력 시 동일 인덱스에 누적 덧셈 수행 |
| **시간복잡도**  | O(N×M)                                                                                     |
| **사용 API** | `new[]`, `std::cin`, `std::cout`                                                           |
| **경과시간**   | 1시간 이상                                                                                     |
| **결과**     | FAIL                                                                                       |
| 재풀이여부      | O                                                                                          |

---
### 메모

- 동적할당을 통해 진행할 경우 `array2D`와 `array1D`라는 변수명으로 접근하는 것을 권장
- `N`은 행의 개수이며 M이 열의 개수임을 똑바로 인지해야함
- 일반적으로는 최대 크기가 주어지기 때문에 동적할당이 아닌 `int[100][100]`과 같은 하드코딩 정적 할당의 형태로 사용함
- 동적할당으로 사용할 경우는 `vector<vector<int>> matrix(N, vector<int>(M))`의 형태로 사용하는 것을 권장함  

---
### GPT 피드백

- “행 단위로 1차 배열을 만들고, 그 포인터를 2차 포인터에 저장한다”는 설계 의도가 실제 코드 흐름과 정확히 일치함
    
- 출력 또한 `N줄 × M개` 형태로 문제 요구사항과 완전히 일치함
    
- 다만 코딩 테스트 관점에서는 다음과 같은 점을 인지할 필요가 있음
    - 이 문제에 `int**`는 정석이라기보다는 **학습 목적 구현**
    - 실전에서는 `vector<vector<int>>` 또는 정적 배열이 더 안전하고 간결함

---
### 정석 코드 제안
#### 정석 코드: 정적 배열을 사용한 정석 풀이이
```cpp
#include <iostream>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int N, M;
    std::cin >> N >> M;

    int matrix[100][100] = {};

    for (int i = 0; i < N; ++i)
        for (int j = 0; j < M; ++j)
            std::cin >> matrix[i][j];

    for (int i = 0; i < N; ++i)
        for (int j = 0; j < M; ++j)
        {
            int temp;
            std::cin >> temp;
            matrix[i][j] += temp;
        }

    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < M; ++j)
            std::cout << matrix[i][j] << ' ';
        std::cout << '\n';
    }

    return 0;
}
```

#### 동적 배열(`vector<vector<int>>`)을 사용한 정석 풀이
```cpp
#include <iostream>
#include <vector>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int N, M;
    std::cin >> N >> M;

    std::vector<std::vector<int>> matrix(N, std::vector<int>(M));

    // 첫 번째 행렬 입력
    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < M; ++j)
        {
            std::cin >> matrix[i][j];
        }
    }

    // 두 번째 행렬 입력 + 덧셈
    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < M; ++j)
        {
            int temp;
            std::cin >> temp;
            matrix[i][j] += temp;
        }
    }

    // 출력
    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < M; ++j)
        {
            std::cout << matrix[i][j] << ' ';
        }
        std::cout << '\n';
    }

    return 0;
}
```


---
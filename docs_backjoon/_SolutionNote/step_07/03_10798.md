### 기본정보

| TITLE      | VALUE                                                                                                   |
| ---------- | ------------------------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.02                                                                                              |
| **번호**     | 10798                                                                                                   |
| **아이디어**   | 길이가 서로 다른 5개의 문자열을 입력으로 받아, <br>열 인덱스를 기준으로 세로 방향으로 순회하며 <br>**해당 위치에 문자가 실제로 존재하는 경우에만 출력**하여 세로 읽기 구현 |
| **시간복잡도**  | O(5 × 15) = O(1)                                                                                        |
| **사용 API** | `std::string`, `std::cin`, `std::cout`, `size()`                                                        |
| **경과시간**   | 15분                                                                                                     |
| **결과**     | FAIL                                                                                                    |
| 재풀이여부      | O                                                                                                       |

---
### 메모

- 문제의 핵심 아이디어(세로 순회 및 존재 여부 판단)는 올바르게 파악했으나, **문제의 개념 모델에 맞지 않는 자료구조를 선택**하여 오답이 발생함
  
- 본 문제는 겉보기에는 2차원 배열 문제처럼 보이나, 실제로는 **길이가 서로 다른 1차원 문자열 5개의 집합**으로 해석하는 것이 적절함
  
#### 2차원 배열이 적합한 경우

- 모든 좌표가 항상 유효하며, 데이터가 비어 있는 것 또한 상태의 일부일 때
    
- 좌표 기반의 데이터 접근이 핵심일 때
    
- 저장 공간을 먼저 확정하고, 이후 데이터를 채워 넣는 문제 구조일 때
    
- 예: 체스판, 보드 게임, 텍스처, ASCII 캔버스 등
	  
#### 1차원 배열(문자열) 집합이 적합한 경우

- 데이터의 유효성이 각 1차원 시퀀스의 길이에 의해 결정될 때
    
- **‘빈 것’과 ‘없는 것’이 명확히 구분되어야 할 때**
    
- 각 시퀀스마다 유효한 인덱스 범위가 서로 다를 수 있을 때
    
- 예: 다중 문자열 기반 문제, 가변 길이 입력 처리 문제 등

---
### GPT 피드백

- 이 문제에서의 실패 원인은 알고리즘이 아니라 **자료구조 선택 단계**에 있었음
    
- 2차원 배열은 “모든 좌표가 존재하는 격자 모델”을 전제로 하나, 본 문제는 **존재하지 않는 좌표 자체가 의미를 가지는 구조**임
    
- `string`을 사용하고 `j < string.size()`로 존재 여부를 판단하는 방식은 문제의 개념 모델을 가장 직접적으로 코드에 반영한 정석 설계임
    
- `'\0'` 또는 공백 문자 기반 분기는 기술적으로 가능하지만, 이는 문제 의미가 아닌 **구현 세부사항에 의존한 차선책**에 해당함

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <string>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    std::string s[5];

    for (int i = 0; i < 5; ++i)
        std::cin >> s[i];

    for (int j = 0; j < 15; ++j)
    {
        for (int i = 0; i < 5; ++i)
        {
            if (j < s[i].size())
                std::cout << s[i][j];
        }
    }

    return 0;
}
```

---
### 기본정보

| TITLE      | VALUE                                                    |
| ---------- | -------------------------------------------------------- |
| **일시**     | 2026.01.22                                               |
| **번호**     | 11720                                                    |
| **아이디어**   | 숫자 N개를 문자열로 입력받고, 각 문자에서 `'0'`을 빼서 digit 값으로 변환한 뒤 누적 합산 |
| **시간복잡도**  | O(N)                                                     |
| **사용 API** | `std::string`, `std::cin`, `std::cout`                   |
| **경과시간**   | 9분 52초                                                   |
| **결과**     | PASS                                                     |
| 재풀이여부      | X                                                        |

---
### 메모

- 숫자를 문자열로 받으면 각 자리 접근이 쉬움 (`S[i]`)
    
- digit 변환은 `S[i] - '0'`로 충분함(정수로 자동 승격)
    
- 루프 내부에서 `'0'`의 ASCII 값을 매번 `static_cast`로 계산할 필요는 없음
  (상수이므로 바로 `'0'` 사용 권장)
  
---
### GPT 피드백

- `char`, `short`, `int` 등 **정수 타입들은 모두 메모리에 “비트 패턴(값)”을 저장**하며, 차이는 주로 **크기(바이트 수)** 와 **부호(signed/unsigned)** 및 그에 따른 **해석 가능한 범위**에 있습니다.
    
- `char`는 **문자 타입처럼 쓰이지만 본질적으로는 1바이트 정수 타입**입니다. 
  즉, `char` 자체가 “ASCII를 자동으로 매칭해 문자를 반환하는 타입”이라기보다, **1바이트 정수 값을 담는 그릇**이고 이를 문자로 해석하는 것은 **관례/표현(출력) 방식**입니다.
    
- 문자 리터럴 `'A'`, `'0'` 등은 내부적으로 **문자 코드 값(예: ASCII라면 `'A'`=65, `'0'`=48)** 을 의미하며, 같은 값을
    
    - `std::cout << c;` 로 출력하면 **문자처럼 표시**되고
        
    - `std::cout << static_cast<int>(c);` 로 출력하면 **정수처럼 표시**됩니다.  
        즉 “값이 바뀌는 것”이 아니라 **표현 방식이 바뀌는 것**입니다.
        
- `S[i] - '0'` 같은 연산이 가능한 이유는, 산술 연산 시 `char`가 자동으로 **정수 승격(int promotion)** 되어 **`int - int` 연산으로 처리**되기 때문이며, 이때 결과도 `int`가 됩니다.

---
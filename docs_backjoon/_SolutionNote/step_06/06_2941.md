### 기본정보

| TITLE      | VALUE                              |
| ---------- | ---------------------------------- |
| **일시**     | 2026.01.29                         |
| **번호**     | 2941                               |
| **아이디어**   | 특정 문자열 패턴을 하나의 문자로 간주하여 문자열 길이를 계산 |
| **시간복잡도**  | O(N) (문자열 길이 N)                    |
| **사용 API** | `std::string`,`std::substr`        |
| **경과시간**   | 약 20분                              |
| **결과**     | FAIL                               |
| 재풀이여부      | O                                  |

---
### 메모

```cpp
std::string.substr(size_t startIdx, size_t count)
```

- 문자열의 `startIdx` 위치부터 `count` 길이만큼 잘라 **부분 문자열을 생성**하는 API
- 문자열을 **현재 인덱스 기준으로 분해하며 비교**하는 문제에 적합

#### 문제 유형 정리

- 흔히 “파싱 문제”로 분류되지만, CS 이론적으로 구분하면 다음과 같음
    
**Parsing (구문 분석)**

- 토큰 간의 구조·문법 관계를 해석
- 문법 규칙, 계층 구조(AST)를 전제로 함
    

**Lexical Analysis (어휘 분석)**

- 입력 문자열을 **의미 있는 토큰 단위로 분해**
- 토큰의 종류와 길이를 인식하는 단계
    
- 본 문제(BOJ 2941)는  
    문자열을 왼쪽부터 순차적으로 읽으며 **사전 정의된 문자열 패턴을 하나의 토큰으로 인식**하므로 **구문 분석이 아닌 어휘 분석(토큰화)에 더 가까운 문제**

#### 문제 적용 개념

- 문자열을 **왼쪽부터 순차적으로 탐색**
    
- 현재 인덱스 `i`에서:
    
    1. 비교해야 할 패턴 길이만큼 `substr`로 잘라냄
        
    2. 사전에 정의된 문자열 패턴과 일치하는지 비교
        
    3. 일치하면:
        
        - 해당 패턴 길이만큼 인덱스를 증가 (`i += length`)
            
        - 결과 카운트 증가
            
    4. 일치하지 않으면:
        
        - 다음 후보 패턴(더 짧은 길이)으로 동일 과정 반복
            
- 모든 패턴에 해당하지 않으면 **일반 문자 1개 처리**

#### 핵심 포인트

- **가장 긴 패턴부터 비교**해야 중복 매칭을 방지할 수 있음 (`dz=` 우선)
    
- `substr` 사용 시 **인덱스 범위 체크 필수**

---
### GPT 피드백

- 이 문제는 문자열 검색 문제가 아니라 **순차 파싱 문제**
- 왼쪽부터 읽으면서 **패턴 우선순위를 적용**하는 방식이 정석
- 출력은 패턴 개수가 아닌 **최종 글자 수**

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <string>

int main()
{
	std::ios::sync_with_stdio(0);
	std::cin.tie(0);
	
	std::string S;
	std::cin >> S;
	
	int count = 0;
	
	for (int i = 0; i < S.size(); )
	{
		// 문자열의 i번째 문자마다 비교해야하는 문자열의 크기만큼 잘라셔 비교
		
		if (i + 2 < S.size())
		{
			// i번째 문자율부터 크기 3만큼 자름 (i / i + 1 / i + 2)
			std::string three = S.substr(i, 3); 
			
			if (three == "dz=")
			{
				++count;
				i += 3;
				continue;
			}
		}
		
		if (i + 1 < S.size()) 
		{
			// i번째 문자율부터 크기 2만큼 자름 (i / i + 1)
			std::string two = S.substr(i, 2); 
			
			if (two == "c=" || two == "c-" || two == "d-" ||
				two == "lj" || two == "nj" || two == "s=" || two == "z=")
			{
				++count;
				i += 2;
				continue;
			}
		}
		
		// 해당사항 없을 경우
		++count;
		i += 1;
		continue;
	}
	
	std::cout << count;
	
	return 0;
}
```

---
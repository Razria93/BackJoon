### 기본정보

| TITLE      | VALUE                                                    |
| ---------- | -------------------------------------------------------- |
| **일시**     | 2026.01.29                                               |
| **번호**     | 2444                                                     |
| **아이디어**   | 행 기준으로 별의 출력 구간(min, max)을 계산하여 해당 범위만 출력                |
| **시간복잡도**  | O(N²)                                                    |
| **사용 API** | `std::ios::sync_with_stdio`, `std::cin.tie`, `std::cout` |
| **경과시간**   | 1시간 이상                                                   |
| **결과**     | PASS                                                     |
| 재풀이여부      | O                                                        |

---
### 메모

- 출력 문제에서 **줄 끝 공백(trailing space)은 오답 원인**
	- 전체 폭 `(2N-1)`을 고정 출력하면 위험
	- “출력해야 할 문자만 출력”하는 방식이 가장 안전

---
### GPT 피드백

- 좌표 기반(`min / max`) 사고는 정확하며 일반화 가능성이 높음
- 오답의 원인은 로직이 아니라 **출력 포맷 제어**
- 별찍기 문제에서 조건부 공백 출력(`a < min`)은 실전에서 매우 안전한 패턴
- 문제 해결 이후에는 **공백 개수 공식 풀이도 반드시 익혀둘 것**

---
### 정석 코드 제안
#### 정석 코드
```cpp
for (int i = 1; i <= N; ++i)
{
    std::cout << std::string(N - i, ' ');
    std::cout << std::string(2 * i - 1, '*');
    std::cout << '\n';
}

for (int i = N - 1; i >= 1; --i)
{
    std::cout << std::string(N - i, ' ');
    std::cout << std::string(2 * i - 1, '*');
    std::cout << '\n';
}
```

- 각 줄마다 왼쪽에 필요한 공백만 출력한 뒤, 필요한 개수의 별만 출력하겠다는 것
- `std::string(int num, char inchar)` : 길이가 `num`이고, 모든 문자가 `inchar`로 채워진 문자열 생성

#### Manhattan Distance 풀이
```cpp
int center = N;
for (int y = 1; y <= 2 * N - 1; ++y)
{
    for (int x = 1; x <= 2 * N - 1; ++x)
    {
        if (abs(x - center) + abs(y - center) < N)
            std::cout << '*';
        else
            std::cout << ' ';
    }
    std::cout << '\n';
}
```

- **좌표기반 사고방식의 해법**
- 2차원 좌표 평면에서 중심점(center)으로부터의 Manhattan 거리(`L1 거리`)가 일정 값 미만인 지점만 별로 채우는 방식
	
- Manhattan 거리(`L1 거리`)
	- `abs(x - center) + abs(y - center) < N`
	- 격자(grid) 위에서 상·하·좌·우로만 이동할 때, 한 점에서 다른 점까지 가는 데 필요한 최소 이동 칸 수
	- 대각선 이동은 허용되지 않으며, 실제 이동경로는 직각으로 꺾인 경로
	- 이런 특성으로 인해 `도시 블록 거리(City Block Distance)`, `Manhattan 거리`와 비슷하다하여 위와 같은 이름이 붙은 것임
	
- 숫자 사이의 거리는 `abs(a - b)` 이고 숫자 사이의 개수는 `abs(a - b + 1)`

---


### 기본정보

| TITLE      | VALUE                                                                                                                                                     |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.02                                                                                                                                                |
| **번호**     | 2903                                                                                                                                                      |
| **아이디어**   | 1. 전체 점의 개수를 직접 추적하지 않고,<br>2. 최종 점의 개수는 한 변에 존재하는 점의 제곱임을 인지,<br>3. **한 변에 존재하는 점의 개수만을 상태값으로 정의**한 뒤,<br>4. 단계별 변화 규칙을 찾고 <br>5. 최종적으로 제곱하여 전체 점의 개수 계산 |
| **시간복잡도**  | O(N)                                                                                                                                                      |
| **사용 API** | `std::cin`, `std::cout`                                                                                                                                   |
| **경과시간**   | 40분                                                                                                                                                       |
| **결과**     | PASS                                                                                                                                                      |
| 재풀이여부      | O                                                                                                                                                         |

---
### 메모

처음에는 새로 생기는 **점의 개수(변화량)에 집중**했으나, 중복 제거와 포함 여부 판단이 필요해지며 사고가 복잡해짐

문제의 핵심 조건이 **점은 중복되지 않는다**는 점임을 인식한 뒤, 변화량이 아닌 **최종 상태값을 직접 정의하는 방향**으로 접근 방식을 전환함

전체 점의 개수는 $$(한\,변의\,점\,개수)²$$
형태이므로, 문제의 본질은 2차원이 아니라 **1차원 수열 문제**로 환원 가능

---
단계별로 한 변의 점 개수를 직접 나열해 보면 다음과 같음

| 단계 N | 한 변의 점 개수 |
| ---- | --------- |
| 0    | 2         |
| 1    | 3         |
| 2    | 5         |
| 3    | 9         |
| 4    | 17        |

위 값을 통해

```
f(n) = 2 × f(n−1) − 1
```

이라는 **상태 기반 재귀식**을 도출할 수 있음

---

증가량(`f(n) − f(n−1)`)이

```
1, 2, 4, 8, ...
```

형태로 지수적으로 증가하기 때문에, 직관적으로 “2의 거듭제곱이 보인다”는 감각은 타당함

다만 정답에 도달하기 위해서는 증가량을 더하는 방식이 아니라, **상태값 자체가 어떻게 변하는지를 기준으로 식을 세워야 함**

재귀식을 정리하면 닫힌 형태로

```
f(n) = 2^n + 1
```

이 도출되며, 최종 결과는

```
(2^n + 1)^2
```

---
### GPT 피드백

- 이 문제는 재귀 구현 문제가 아닌, **규칙을 발견하고 문제의 차원을 낮출 수 있는지를 묻는 문제**

- **새로 생기는 것(Δ)** 에 집착하면 문제 난이도가 불필요하게 상승하며, **현재 상태가 무엇인가**를 정의하는 순간 구조가 단순해짐
    
- 패턴을 발견할 때의 정석적인 사고 절차는 다음과 같음
    
    1. 전체가 아닌 한 축(한 변)으로 차원 축소
    2. 변화량이 아닌 상태값 관찰
    3. 직접 값 4~5개 나열
    4. 이전 값으로 다음 값이 결정되는지 확인
    5. 재귀식 → 닫힌식 순으로 정리
        
- 이 문제는 위 절차를 그대로 적용했을 때 **자연스럽게 풀리는 전형적인 규칙 발견 문제**

---
### 정석 코드 제안
#### 정석 코드

```cpp
#include <iostream>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int N;
    std::cin >> N;

    int side = (1 << N) + 1;   // 2^N + 1
    std::cout << side * side;

    return 0;
}
```

---
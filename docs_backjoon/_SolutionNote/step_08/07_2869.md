### 기본정보

| TITLE      | VALUE                                           |
| ---------- | ----------------------------------------------- |
| **일시**     | 2026.02.04                                      |
| **번호**     | 2869                                            |
| **아이디어**   | 마지막 날을 분리한 뒤, 하루 순증가량 `(A - B)` 기준으로 **수학적 계산** |
| **시간복잡도**  | **O(1)**                                        |
| **사용 API** | `std::cin`, `std::cout`                         |
| **경과시간**   | 15분                                             |
| **결과**     | PASS                                            |
| 재풀이여부      | X                                               |

---
### 메모

- 1차 구현은 `while문`으로 시간복잡도 `O(N)`의 형태로 구현함
- 위 구현은 시간 초과 발생
- 문제를 재분석하고 기본적인 산술 연산으로 알고리즘을 변경함
	- 정상 도달 후 미끄러지지 않음 조건에 의해 마지막은 별도로 처리해야함
  
---
### GPT 피드백

- 첫 번째 코드가 시간 초과가 나는 원인은 명확합니다
    → `V`가 최대 **10억**까지 가능하므로, 하루 단위 반복은 비현실적입니다
    
- 두 번째 코드의 접근 방향은 **정확**합니다  
    다만 구조적으로 더 단순하게 정리할 수 있습니다
    
- 현재 코드에서의 핵심 논리는 다음과 같습니다
    
    - 첫 날에 `A`만큼 올라가서 **정상 도달 여부를 즉시 판단**
    - 남은 높이에 대해 `(A - B)` 단위로 며칠이 필요한지 계산
        
- 이 문제는 **반복문 문제처럼 보이지만 실제로는 산술 문제**입니다

---
### 정석 코드 제안

#### 핵심 수식

> **Ceiling Division**
> `ceil(V / (A - B))` 혹은 `(remain + daily - 1) / daily`
> 
> - 후자의 경우 `remain`에서 나머지가 발생할 경우 `daily - 1`과 더해져 분모의 값보다 커지게 되므로 버림연산 기반으로도 나머지가 올림 처리되는 효과를 구현 할 수 있음

#### 정석 코드
```cpp
#include <iostream>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    long long A, B, V;
    std::cin >> A >> B >> V;

    // 마지막 날 제외 후 남은 높이
    long long remain = V - A;

    // 마지막 날 하루
    long long day = 1;

    if (remain > 0)
    {
        long long daily = A - B;
        day += (remain + daily - 1) / daily; // ceil division
    }

    std::cout << day;
    return 0;
}
```

---
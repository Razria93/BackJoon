### 기본정보

| TITLE      | VALUE                   |
| ---------- | ----------------------- |
| **일시**     | 2026.02.03              |
| **번호**     | 2292                    |
| **아이디어**   | 최소 방의                   |
| **시간복잡도**  | O(√N)                   |
| **사용 API** | `std::cin`, `std::cout` |
| **경과시간**   |                         |
| **결과**     | PASS                    |
| 재풀이여부      | O                       |

---
### 메모

- 문제는 `벌집의 중앙 1에서 N번방까지 최소 개수의 방을 지나서 갈때 맻개의 방을 지나가는지` 라는 거리를 구하라는 문제로 보임
  
- 그래서 방향 별로 숫자의 증가 규칙에 초점을 두고 각 방향의 숫자 증감 규칙을 찾았으나 너무 복잡하여 해결의 실마리가 보이지 않음
  
- 그래서 문제를 재해석하고자 하였고 `인덱스가 중심으로부터 껍질(레이어)의 형태로 매겨진다`는 부분에 주목하여 주어지는 `인덱스가 어떤 레이어에 속하는지` 먼저 알고자 하였으며, 결과적으로 해당 접근 방식 자체가 문제의 정답에 해당하였음
  
- 같은 도형으로 빈틈없이 채울 수 있고 인접한 도형과 모두 선으로 맞닿아있는 육각형은 같은 `레이어의 속한 인덱스들의 경우 중심으로부터의 거리가 모두 동일`하며, `그 거리는 레이어 인덱스와 같거나 비슷함` (자세한 것은 레이어 인덱스 규칙 및 거리 측정 규칙에 따라 다름)

- 이는 빈틈없이 채울 수 있는 도형인 사각형도 마찬가지로 적용되나, 사각형은 육각형과 달리 인접해있는 셀이 `점`으로 맞닿아있는 경우도 있고 `선`으로 맞닿아있는 경우도 있어서 `이동 규칙에 따라 레이어가 다른 형태로 형성됨`
  
---
### GPT 피드백

- 이 문제를 좌표·방향·경로 문제로 해석하면 불필요하게 복잡해짐
    
- 육각 격자의 구조적 특성상 각 레이어의 셀 수가 항상 `6n`으로 증가하므로, 누적 합 비교만으로 해결 가능함
    
- “같은 레이어 = 같은 최소 이동 횟수”라는 인식은 맞지만, 실제 거리 계산은 요구되지 않음

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>

int main()
{
    size_t N;
    std::cin >> N;

    size_t layer = 0;

    while (true)
    {
        size_t maxValue = 1 + 3 * layer * (layer + 1);

        if (N <= maxValue)
            break;

        ++layer;
    }

    std::cout << layer + 1;
    return 0;
}
```

---
### 기본정보

| TITLE      | VALUE                                                     |
| ---------- | --------------------------------------------------------- |
| **일시**     | 2026.02.02                                                |
| **번호**     | 2720                                                      |
| **아이디어**   | 거스름돈을 가장 큰 단위의 동전부터 차례대로 나누어 <br>몫과 나머지를 계산하는 방식 (그리디 방식) |
| **시간복잡도**  | O(N)                                                      |
| **사용 API** | `std::cin`, `std::cout`                                   |
| **경과시간**   | 10분                                                       |
| **결과**     | PASS                                                      |
| 재풀이여부      | X                                                         |

---
### 메모

- 미국 동전 체계(25, 10, 5, 1)는 **그리디 전략이 항상 최적해를 보장**하는 구조
- 상위 동전이 하위 동전의 조합을 커버할 수 있으므로 상위 동전부터 차례차례 구해나가면 됨

---
### GPT 피드백

- - 이 문제는 **최소 동전 개수** 문제가 아니라 **동전의 개수를 단위별로 출력하는 문제**이므로,  
    정해진 순서대로 나누는 방식이 가장 명확한 정석 풀이
    
- 그리디가 항상 성립하는 이유(동전 단위가 배수 관계)는 문제 조건에 이미 내재되어 있음
    
- `size_t`를 사용해 음수 가능성을 제거한 점은 안전하지만, 문제 특성상 `int`를 사용해도 무방함
    
- 불필요한 자료구조나 반복문 없이 **연산 흐름이 한눈에 보이는 구현**임

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int T;
    std::cin >> T;

    int coin[4] = {25, 10, 5, 1};

    while (T--)
    {
        int C;
        std::cin >> C;

        for (int i = 0; i < 4; ++i)
        {
            std::cout << C / coin[i] << ' ';
            C %= coin[i];
        }
        std::cout << '\n';
    }

    return 0;
}
```

---
### 기본정보

| TITLE      | VALUE                                                         |
| ---------- | ------------------------------------------------------------- |
| **일시**     | 2026.02.09                                                    |
| **번호**     | 19532                                                         |
| **아이디어**   | `x, y`를 -999부터 999까지 완전탐색하며<br>두 방정식을 동시에 만족하는 해를 찾으면 출력 후 종료 |
| **시간복잡도**  | `O(R^2)` (R=1999) ≈ 약 4,000,000회 검사                           |
| **사용 API** | -                                                             |
| **경과시간**   | 5분                                                            |
| **결과**     | PASS                                                          |
| 재풀이여부      | X                                                             |

---
### 메모

- 주어진 시간에만 값을 도출 할 수 있다면 무식한 풀이 방법도 좋은 해법일 수 있음

- 해당 방법은 전체를 순회하는 비용이 상당한 방법이므로 사용하기 이전에 시간복 잡도와 예상 루프 횟수를 고려하는 습관을 들이면 좋을 것 같음
  
---
### GPT 피드백

- 알고리즘 선택은 정석입니다. 이 문제는 **완전탐색이 가장 안정적**이고 구현 실수도 적습니다.
    
- 다만 현재 코드 구조에서 `break`는 Y 루프만 빠져나오므로, 해를 찾은 뒤에도 X 루프가 계속 돕니다. **정답이 유일해라 출력은 보통 한 번으로 끝나지만**, 종료 처리는 명확히 고치는 편이 좋습니다.
    
- 개선 우선순위는 1개입니다: **해를 찾으면 즉시 종료(`return`)**.

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int a, b, c, d, e, f;
    std::cin >> a >> b >> c >> d >> e >> f;

    for (int x = -999; x <= 999; ++x)
    {
        for (int y = -999; y <= 999; ++y)
        {
            if (a * x + b * y == c && d * x + e * y == f)
            {
                std::cout << x << ' ' << y;
                return 0; // early exit
            }
        }
    }

    return 0;
}
```

---
### 기본정보

| TITLE      | VALUE                                                                                                                                      |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **일시**     | 2026.02.09                                                                                                                                 |
| **번호**     | 1436                                                                                                                                       |
| **아이디어**   | 브루트포스로 `numbering`을 0부터 증가시키며 <br>666 포함 여부를 검사<br>`Check666(numbering)`가 true인 경우 카운트를 증가시키고, <br>카운트가 N번째(`IDX`)가 되는 순간의 `numbering`을 출력 |
| **시간복잡도**  | O(T · D) (T=찾을 때까지 검사한 숫자 개수, D=자릿수(검사 비용))                                                                                                |
| **사용 API** | 기본 I/O, 모듈로/나눗셈 기반 자릿수 검사                                                                                                                  |
| **경과시간**   | 40분                                                                                                                                        |
| **결과**     | PASS                                                                                                                                       |
| 재풀이여부      | O                                                                                                                                          |

---
### 메모

- 연속된 문자열을 찾는 것이 핵심인 문제

- `std::string`의 `find`를 이용하여 더 명확하게 찾는 방법이 있으므로 해당 방식으로 재풀이 요망
  
---
### GPT 피드백

- `if (cached == 0) return false;`는 `numbering`이 0부터 시작할 때 불필요한 검사를 피하는 정도의 의미이며 동작에 문제 없음
    
- 이 문제는 문자열 변환(`to_string`) + 부분 문자열 검색(`find("666")`) 방식도 정석으로 많이 쓰이며 구현이 더 직관적임

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <string>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;

    int count = 0;
    int x = 665;

    while (count < n)
    {
        ++x;

        std::string s = std::to_string(x);
        if (s.find("666") != std::string::npos)
        {
            ++count;
        }
    }

    std::cout << x;
    return 0;
}
```

---
### 기본정보

| TITLE      | VALUE                                                                                               |
| ---------- | --------------------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.09                                                                                          |
| **번호**     | 1018                                                                                                |
| **아이디어**   | 모든 8×8 시작 위치를 순회하며, <br>시작 색이 `W`인 패턴과 `B`인 패턴 각각에 대해 <br>64칸을 이상적 패턴과 비교해 repaint 횟수를 계산하고 최솟값을 갱신 |
| **시간복잡도**  | `O((N-7)(M-7) * 64)` (패턴 2개는 상수)                                                                    |
| **사용 API** | `std::vector`, `std::min`, `INT_MAX`                                                                |
| **경과시간**   | 1시간                                                                                                 |
| **결과**     | PASS                                                                                                |
| 재풀이여부      | O                                                                                                   |

---
### 메모

- 풀이 알고리즘은 맞았으나, M과 N의 축방향을 다르게 사용하고 있음을 너무 늦게 인지하여 디버깅 시간이 길어짐

- `Count()` 함수에서 하드코딩된 `8`을 `InWidth`로 바꾸는 것도 늦게 인지하였음

- `std::string[]`을 사용했다면 2차원 배열처럼 사용할 수 있어서 비교적 코드가 간결해질 수 있었음
  
- 다만 위 방식을 사용할 땐 `string`의 배열번호가 먼저와야 하므로 `string[y][x]`과 같이 접근해야함

- 그래도 끝까지 포기하지 않고 디버깅하여 풀어낸 점은 스스로도 대단하다 생각함
  
---
### GPT 피드백

- **알고리즘 선택은 정석입니다.** 1018은 사실상 “모든 8×8을 검사 + 두 패턴 비교”가 표준 풀이입니다.
    
- 다만 코드 품질/오해 소지가 있는 지점이 몇 개 있습니다(명확히 개선 권장).
    
    1. `Count()` 파라미터 네이밍이 혼동을 유발합니다.
        
        - 최소한 `startX, startY, width`로 바꾸는 게 안전합니다.
            
    2. `Count()` 내부 패턴 생성이 불필요하게 장황합니다.
        
        - `(i+j)%2`에 따라 `'W'/'B'`를 고르는 로직은 맞지만, 삼항이 중복됩니다.
            
        - 더 간단히 `expected = ((i+j)%2==0 ? startColor : oppositeColor)` 형태로 정리 가능합니다.
            
    3. 입력을 `N*M`번 `cin >> C`로 받는 방식은 동작합니다.
        
        - 다만 문제 입력은 보통 “한 줄에 M개 문자열”이므로, `std::string row; cin >> row;`로 행 단위로 읽는 게 더 명확합니다(공백 없음이라 안전).
            
    4. 성능은 충분합니다.
        
        - `Count()`를 두 번 호출하는 구조도 괜찮습니다(상수배). 더 줄이고 싶으면 “한 번 계산해서 64 - count” 트릭이 있지만 필수는 아닙니다.
            

**중요한 개선 포인트(정답 안정성 관점)**

- 지금 `break` 같은 탈출 이슈는 없고, 인덱싱 `[(x+i) + (y+j)*M]`도 정상입니다.
    
- 즉, 이 문제에서 가장 흔한 오답 원인은 “패턴이 뒤집힘 / 인덱스 축 혼동 / 시작좌표 범위 오류”인데, 현재 코드는 그 부분이 정석적으로 처리되어 있습니다.
  
---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <string>
#include <algorithm>

int repaintCount(const std::string board[], int startY, int startX, char startColor)
{
    int cnt = 0;
    for (int y = 0; y < 8; ++y)
    {
        for (int x = 0; x < 8; ++x)
        {
            char expected = ((y + x) % 2 == 0) ? startColor : (startColor == 'W' ? 'B' : 'W');
            if (board[startY + y][startX + x] != expected) ++cnt;
        }
    }
    return cnt;
}

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int N, M;
    std::cin >> N >> M;

    std::string board[50];
    for (int i = 0; i < N; ++i) std::cin >> board[i];

    int ans = 64;
    for (int y = 0; y + 8 <= N; ++y)
    {
        for (int x = 0; x + 8 <= M; ++x)
        {
            int w = repaintCount(board, y, x, 'W');
            int b = repaintCount(board, y, x, 'B');
            ans = std::min(ans, std::min(w, b));
        }
    }

    std::cout << ans;
    return 0;
}
```

---
### 기본정보

| TITLE      | VALUE                                                                                                                |
| ---------- | -------------------------------------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.09                                                                                                           |
| **번호**     | 2798                                                                                                                 |
| **아이디어**   | 카드를 오름차순으로 정렬한 뒤,<br>3중 루프로,<br>3장 조합을 완전탐색부분합이 `M`을 초과하는 순간,<br>이후는 더 커지므로 `break`로 조기 종료.<br>`합 ≤ M`인 조합 중 최댓값을 갱신 |
| **시간복잡도**  | 정렬 `O(N log N)` + 탐색 `O(N^3)`                                                                                        |
| **사용 API** | `std::vector`, `std::sort`                                                                                           |
| **경과시간**   | 20분                                                                                                                  |
| **결과**     | PASS                                                                                                                 |
| 재풀이여부      | X                                                                                                                    |

---
### 메모

- 주어진 모든 카드를 vector에 저장한 뒤,
- 정렬하여 작은 값들부터 모두 더해가며 Max를 갱신함
- 오름차 순으로 정렬하였기 때문에 각 루프에서 M값을 초과할 경우 이후의 값들은 오버플로우 이므로 break로 조기 종료
- 그러나 순수한 완전탐색 알고리즘은 모든 경우의 수를 정복하는 것이 핵심임으로 정렬없이 3중 for문으로 더한 수를 M과 Max와 비교함
  
---
### GPT 피드백

- **핵심 알고리즘 선택은 적절합니다.** 2798은 제약(`N ≤ 100`)상 `O(N^3)` 완전탐색이 정석이고, 정렬 + 조기 종료는 깔끔한 미세 최적화입니다.
  
- 정렬은 필수는 아닙니다. “가장 정석” 코드는 보통 정렬 없이 3중 루프로 끝냅니다(단, 정렬+break는 충분히 합리적 최적화입니다).

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int N, M;
    std::cin >> N >> M;

    std::vector<int> a(N);
    for (int i = 0; i < N; ++i) std::cin >> a[i];

    int best = 0;

    for (int i = 0; i < N; ++i)
    {
        for (int j = i + 1; j < N; ++j)
        {
            for (int k = j + 1; k < N; ++k)
            {
                int sum = a[i] + a[j] + a[k];
                if (sum <= M) best = std::max(best, sum);
            }
        }
    }

    std::cout << best;
    return 0;
}
```

---
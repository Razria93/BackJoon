### 기본정보

| TITLE      | VALUE                                               |
| ---------- | --------------------------------------------------- |
| **일시**     | 2026.02.04                                          |
| **번호**     | 2581                                                |
| **아이디어**   | 구간 `[M, N]`을 순회하며 **소수 판별식**으로 소수의 합과 최소 소수를 동시에 계산 |
| **시간복잡도**  | **O((N − M + 1) · √N)**                             |
| **사용 API** | `std::cin`, `std::cout`                             |
| **경과시간**   | 20분                                                 |
| **결과**     | PASS                                                |
| 재풀이여부      | X                                                   |

---
### 메모

- 소수 판별의 기본형
  
---
### GPT 피드백

- √N 소수 판별 구조를 정확히 적용함
    
- 불필요한 상태 변수(`bIsValid`)는 제거 가능
    
- 타입(`int` / `size_t`)의 의미 일관성을 유지하는 습관이 필요
    
- 입력 범위가 작아 체 알고리즘은 불필요
  
---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>

bool IsPrime(size_t n)
{
    if (n < 2) return false;

    for (size_t i = 2; i <= n / i; ++i)
    {
        if (n % i == 0)
            return false;
    }
    return true;
}

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    size_t M, N;
    std::cin >> M >> N;

    size_t sum = 0;
    size_t minPrime = 0;

    for (size_t i = M; i <= N; ++i)
    {
        if (IsPrime(i))
        {
            sum += i;
            if (minPrime == 0)
                minPrime = i;
        }
    }

    if (minPrime == 0)
        std::cout << -1 << '\n';
    else
        std::cout << sum << '\n' << minPrime << '\n';

    return 0;
}
```

---
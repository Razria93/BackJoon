### 기본정보

| TITLE      | VALUE                                      |
| ---------- | ------------------------------------------ |
| **일시**     | 2026.02.04                                 |
| **번호**     | 1978                                       |
| **아이디어**   | 각 입력된 수에 대해 **√N까지 검사**로 소수 여부 판별 후 개수 카운트 |
| **시간복잡도**  | **O(N · √K)** (N = 입력 개수, K = 수의 최대값)      |
| **사용 API** | `std::cin`, `std::cout`                    |
| **경과시간**   | 40분                                        |
| **결과**     | PASS                                       |
| 재풀이여부      | O                                          |

---
### 메모

- 소수 판별을 위해서는 다음을 기억하면 됨
	- `InValue == 1` 는 소수가 아니므로 `return false`로 `early return`
	- 검사를 하는 범위는 `for (int i = 2; i * i < InValue; ++i)`
		- 소수는 약수가 1과 자기 자신인 수
		- 약수를 검사하는 알고리즘이기 때문에 `i * i < InValue` 범위를 가짐
		- 장기적으로는 `i * i < InValue` 는 `i`가 커지면 `overflow`가 비교적 쉽게 발생할 수 있기 때문에 `i < InValue / i` 범위로 체크
  
---
### GPT 피드백

- 기본적인 소수 판별 구조를 정확히 이해하고 있음
    
- 특례 처리보다 **일반식 하나로 정리하는 습관**이 바람직
    
- 이 문제는 소수 문제의 **가장 기본형**

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>

bool IsPrime(size_t n)
{
    if (n < 2) return false;

    for (size_t i = 2; i <= n / i; ++i)
    {
        if (n % i == 0)
            return false;
    }
    return true;
}

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    size_t N;
    std::cin >> N;

    size_t count = 0;

    for (size_t i = 0; i < N; ++i)
    {
        size_t x;
        std::cin >> x;

        if (IsPrime(x))
            ++count;
    }

    std::cout << count;
    return 0;
}
```

---
### 기본정보

| TITLE      | VALUE                           |
| ---------- | ------------------------------- |
| **일시**     | 2026.02.04                      |
| **번호**     | 2501                            |
| **아이디어**   | A의 약수를 오름차순으로 수집한 뒤, B번째 약수를 출력 |
| **시간복잡도**  | **O(N)**                        |
| **사용 API** | `std::vector`, `%`              |
| **경과시간**   | 10분                             |
| **결과**     | PASS                            |
| 재풀이여부      | O                               |

---
### 메모

- `%`를 기반으로 약수에 해당하는 값들을 순서대로 `vector`에 저장
- `1`부터 `A`까지 순회하기 때문에 시간복잡도가 `O(N)`
  
---
### GPT 피드백

- 문제 요구사항을 정확히 만족하는 구현
    
- 다만 약수 문제는 **√A 기준 탐색**으로 사고를 고정하는 것이 바람직
    
- 벡터에 전부 저장하지 않고도 해결 가능
    
- 코딩 테스트 관점에서는 **최적화 아이디어까지 도출하는 연습 필요**

---
### 정석 코드 제안

#### 핵심 아이디어 (√A 기반) 

- 약수는 pair로 존재하며, `i`가 약수이면 `A / i`도 약수
    
- 작은 약수 / 큰 약수를 분리해서 관리
    
- 불필요한 전체 순회 제거

#### 정석 코드
```cpp
#include <iostream>
#include <vector>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    size_t A, B;
    std::cin >> A >> B;

    std::vector<size_t> small, large;

    for (size_t i = 1; i * i <= A; ++i) // i * i <= A
    {
        if (A % i == 0)
        {
            small.push_back(i);
            if (i != A / i) // i != A / i
                large.push_back(A / i);
        }
    }

    // small은 오름차순, large는 내림차순
    if (B <= small.size())
    {
        std::cout << small[B - 1];
    }
    else if (B <= small.size() + large.size())
    {
        std::cout << large[small.size() + large.size() - B];
    }
    else
    {
        std::cout << 0;
    }

    return 0;
}
```

- `i * i <= A`
	- 약수는 `√A` 값을 기준으로 대칭으로 존재함
	- 따라서 `√A` 값까지 체크할 때, `i`와 `A/i`를 같이 해준다면 탐색구간이 좁아짐

- `i != A / i`
	- 약수의 개수가 홀수일 때는 `√A`에 해당하는 값은 자기자신과 페어임 (`√A`, `√A`)
	- 그러나 `small`과 `larget`에 모두 저장할 경우 중복 저장이기 때문에 small 쪽에만 저장

- `large[small.size() + large.size() - B]`
	- `small.size() + large.size()`는 `Size`
	- `B`는 `1-based index`
	- 둘 다 `-1`을 해야 `0-based index`가 되므로 `-1`을 하였으나 상쇄되어 사라진 것

#### 정석코드 (벡터없이 구현)
```cpp
#include <iostream>
#include <cmath>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    size_t A, B;
    std::cin >> A >> B;

    size_t count = 0;
    size_t root = static_cast<size_t>(std::sqrt(A));

    // 1단계: 작은 약수
    for (size_t i = 1; i <= root; ++i)
    {
        if (A % i == 0)
        {
            ++count;
            if (count == B)
            {
                std::cout << i;
                return 0;
            }
        }
    }

    // 전체 약수 개수 계산
    size_t total = count * 2;
    if (root * root == A)
        --total;

    if (B > total)
    {
        std::cout << 0;
        return 0;
    }

    // 2단계: 큰 약수
    size_t target = total - B + 1;
    count = 0;

    for (size_t i = 1; i <= root; ++i)
    {
        if (A % i == 0)
        {
            ++count;
            if (count == target)
            {
                std::cout << A / i;
                return 0;
            }
        }
    }

    return 0;
}
```

---
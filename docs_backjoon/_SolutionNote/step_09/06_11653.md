### 기본정보

| TITLE      | VALUE                                    |
| ---------- | ---------------------------------------- |
| **일시**     | 2026.02.04                               |
| **번호**     | 11653                                    |
| **아이디어**   | 가장 작은 나눌 수 있는 수부터 반복적으로 나누며 소인수를 제거하고 출력 |
| **시간복잡도**  | **O(N)**                                 |
| **사용 API** | `std::cin`, `std::cout`                  |
| **경과시간**   | 10분                                      |
| **결과**     | PASS                                     |
| 재풀이여부      | O                                        |
|            |                                          |

---
### 메모

- 본인은 `N % Prime == 0` 인 소수들을 작은 수부터 찾아서 `N /= Prime`하고자 하였음

- 그리고 `Prime`의 위치에 `2 이상 N 이하의` 모든 수를 대입 시켜 누락되는 인수가 없게 하였음

- 그러나 해당 알고리즘은 결국 N에 대하여 `가장 작은 소수와 나머지 수로 이루어진 합성수`라는 `pair`의 형태를 강제하기 때문에 나누는 쪽은 반드시 `√N`보다 작게 되어 있음

- 이는 마지막에 소수 2개로 이루어진 수가 남더라도 똑같이 적용됨. 소수가 2개더라도 **하나는 비교적 작은 수**로 `√N`보다 작을 것이고 **하나는 큰 수**로 `√N`보다 클 것이기 때문임

- 따라서 나눌 인수를 탐색할 때 `√N`보다 작은 경우만 탐색하면 되며, 탐색에 실패했다면 해당 수는 더이상 나눌 수 없는 소수라는 뜻으로 가장 큰 소수가 됨
  
---
### GPT 피드백

- 메모에 포함되어 있음

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    int N;
    std::cin >> N;

    for (int p = 2; p * p <= N; ++p)
    {
        while (N % p == 0)
        {
            std::cout << p << '\n';
            N /= p;
        }
    }

    // √N 이하에서 더 이상 나눌 수 없다면
    // 남은 N은 마지막 소인수
    if (N > 1)
    {
        std::cout << N << '\n';
    }

    return 0;
}
```

---
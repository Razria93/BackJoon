### 기본정보

| TITLE      | VALUE                                               |
| ---------- | --------------------------------------------------- |
| **일시**     | 2026.02.04                                          |
| **번호**     | 9506                                                |
| **아이디어**   | 자기 자신을 제외한 약수들의 합을 구해 **완전수(Perfect Number)** 여부 판별 |
| **시간복잡도**  | **O(N)**                                            |
| **사용 API** | `std::vector`, `%`                                  |
| **경과시간**   | 20분                                                 |
| **결과**     | PASS                                                |
| 재풀이여부      | X                                                   |

---
### 메모

-  `-1`은 **sentinel(종료 신호)** 이므로 입력되는 즉시 `break`
    
- 완전수 판별에는 **자기 자신(N)을 제외한 약수만** 포함
    
- 출력 포맷 때문에 **약수 목록 저장이 필요**

- `Sum`만 출력하면 되는 문제였을 경우 탐색 과정에서 약수만 Sum에 더하면 됨
    
- 약수는 항상 **쌍(divisor pair)** 으로 존재 → √N 탐색이 정석
  
---
### GPT 피드백

- 단순 `1 ~ N-1` 순회도 통과는 가능하지만 **사고 방식은 비정석**
    
- √N 기반 탐색으로 **시간복잡도와 사고 구조**를 동시에 개선 가능
    
- 불필요한 변수는 제거하고, 입력 루프에서 **종료 판정 선행**이 바람직

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    while (true)
    {
        int N;
        std::cin >> N;

        if (N == -1)
            break;

        std::vector<int> factors;
        int sum = 0;

        for (int i = 1; i * i <= N; ++i)
        {
            if (N % i == 0)
            {
                int j = N / i;

                if (i != N)
                {
                    factors.push_back(i);
                    sum += i;
                }

                if (j != i && j != N)
                {
                    factors.push_back(j);
                    sum += j;
                }
            }
        }

        std::sort(factors.begin(), factors.end()); // std::sort

        if (sum != N)
        {
            std::cout << N << " is NOT perfect.\n";
        }
        else
        {
            std::cout << N << " = ";
            for (int i = 0; i < factors.size(); ++i)
            {
                std::cout << factors[i];
                if (i + 1 < factors.size())
                    std::cout << " + ";
            }
            std::cout << '\n';
        }
    }

    return 0;
}

```

---
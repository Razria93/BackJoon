### 기본정보

| TITLE      | VALUE                                                                           |
| ---------- | ------------------------------------------------------------------------------- |
| **일시**     | 2026.02.10                                                                      |
| **번호**     | 10989                                                                           |
| **아이디어**   | 값 범위(1~10000)가 작으므로 <br>카운팅 배열 `A[value]++`로 개수를 세고, <br>0~10000을 순회하며 카운트만큼 출력 |
| **시간복잡도**  | O(N + K) (K=10001)                                                              |
| **사용 API** | (표준) 고정 배열, 기본 I/O                                                              |
| **경과시간**   | 1시간                                                                             |
| **결과**     | PASS                                                                            |
| 재풀이여부      | O                                                                               |

---
### 메모

- 해당 문제는 의도적으로 입력값의 수를 매우 크게 설정하고 메모리 제한을 두어 `std::sort` 사용을 제한하고 있음
  
- 입력 값의 범위가 10,000인 것을 고려해 `short`를 사용한다 해도 `2 * 10,000,000 byte`로 `20,000KB`, `20MB` 가 되어 메모리 제한인 `8MB`를 넘김

- 따라서 다른 방식으로 푸는 것을 유도하는 것

- 입력 값의 범위가 1만으로 상당히 작은 편인데 반해 입력 값의 수는 최대 10,000,000으로 상당히 중복되는 값들이 많은 것을 알 수 있음

- 해당 방식은 `CountSort` 라는 방식으로 정렬하는 것이 효과적이며 다음과 같은 조건일 때 `CountSort`를 고려해볼 수 있음
  
### CountSort
##### Count Sort를 써야 하는 경우

1. **정렬 대상이 정수**이고
    
2. **값의 범위가 작게 제한**되어 있으며 (K = max-min+1이 작음)
    
3. **N이 충분히 크거나**, 비교정렬(`sort`)이 부담되는 입력 규모이고
    
4. **메모리 O(K)** 를 감당 가능할 때

#### 판단 시그널

- 문제에서 값 범위를 명시적으로 줌
    
    - 예: `1 ≤ x ≤ 10000` 같은 형태
        
- N이 크고(수십만~수백만 이상), 시간 제한이 빡빡
    
- 정렬한 결과를 전부 출력해야 해서, 어차피 `O(N)` 출력이 발생
    
    - 이때 정렬 비용은 최대한 줄이는 게 유리
        
- 중복이 많든 적든 상관없고, **핵심은 값의 범위인 K가 작다는 것**

#### K 범위

- **K ≤ 1e5**: 거의 무조건 카운팅 후보
    
- **K ≤ 1e6**: 메모리/초기화 괜찮으면 강력 후보
    
- **K ≥ 1e7**: 메모리 제한 확인 없으면 “써야 한다”로 보기 어려움 (대개 회피)

---
### GPT 피드백

- 이 풀이가 10989의 **정석(Counting Sort)** 방향이며, 대량 입력에서도 `sort`보다 유리함
    
- 출력 구간에서 `if (A[j] != 0)`는 없어도 동작하지만, 불필요한 루프 진입을 줄여 약간 더 깔끔함
    
- 다만 `while`에 `count` 변수를 따로 두는 것보다, 바로 `for`로 쓰면 더 단순해짐
    
- 문제 입력 값은 1~10000인데 현재 출력 루프가 `j=0`부터 시작함. `0`은 어차피 카운트가 0이라 출력은 안 되지만, **의미상 1부터 도는 편이 더 정확한 표현**임

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;

    int count[10001] = { 0 };

    for (int i = 0; i < n; ++i)
    {
        int x;
        std::cin >> x;
        ++count[x];
    }

    for (int v = 1; v <= 10000; ++v)
    {
        for (int c = 0; c < count[v]; ++c)
        {
            std::cout << v << '\n';
        }
    }

    return 0;
}
```

---
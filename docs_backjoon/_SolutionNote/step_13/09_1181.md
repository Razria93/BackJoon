### 기본정보

| TITLE      | VALUE                                                                           |
| ---------- | ------------------------------------------------------------------------------- |
| **일시**     | 2026.02.10                                                                      |
| **번호**     | 1181                                                                            |
| **아이디어**   | 문자열들을 벡터에 저장 후,<br>비교자에서 **길이 오름차순 → 사전순 오름차순**으로 정렬<br>정렬된 결과에서 인접 중복을 제거하며 출력 |
| **시간복잡도**  | O(N log N · L) (L=평균 문자열 길이, 비교 시 최대 L까지 비교)                                    |
| **사용 API** | `std::vector`, `std::string`, `reserve`, `push_back`, `std::sort`               |
| **경과시간**   | 15분                                                                             |
| **결과**     | PASS                                                                            |
| 재풀이여부      | O                                                                               |

---
### 메모

- 문자열 비교 문제

- 정답은 맞췄고 알고리즘의 방향성 또한 올바르나 깔끔한 구현은 아니므로 피드백을 참고하여 더 나은 방식을 습득하고자 함
  
---
### GPT 피드백

- 정렬 기준(길이 → 사전순)과 중복 제거 출력 방식은 문제 요구사항과 일치함
    
- Comparator 내부에서 사전순 비교를 직접 루프 도는 방식은 동작은 맞음
	
- 그러나 문자열의 기본 비교인 `lhs < rhs`(문자열의 `lexicographical` 비교)를 그대로 쓰면 더 간결하고 실수 여지가 줄어듦
    
- 중복 제거는 현재 `cached` 비교로 정상 동작하지만, 표준적으로는 **정렬 후 `std::unique` + erase**가 더 명확함

#### `std::unique` 와 `std::erase`
##### `std::unique`
- **연속으로 붙어 있는 같은 값**만 하나로 압축하는 API
	1. 연속으로 붙어있어야 하므로 사용전에 반드시 `sort`
	2. 연속으로 붙어있는 값들을 대상으로 중복된 데이터들을 제거함
	3. 배열의 앞부분에 중복이 제거된 요소들을 재배열하여 유효구간을 만듦
	4. 유효구간의 끝을 가리키는 이터레이터(반복자) `it`을 반환함
	5. 컨테이너의 크기는 줄어들지 않으며, 유효한 부분과 유효하지 않은 부분이 아직 공존하고 있음
```cpp
// before
["a", "a", "b", "b", "b", "c"]

// after
["a", "b", "c", ?, ?, ?]
             ^
             it (new end)
```

##### `std::erase`
- **지정된 배열의 구간을 삭제**하는 API
	1. 첫번째 인수부터 두번째 인수 전까지의 구간을 삭제함
	2. 벡터의 실제 `size`가 감소함

```cpp
// 압축 형태
a.erase(std::unique(a.begin(), a.end()), a.end());

// 명시 형태 (압축형태와 기능은 동일함)
auto it = std::unique(a.begin(), a.end());
a.erase(it, a.end());

```

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;

    std::vector<std::string> a;
    a.reserve(n);

    for (int i = 0; i < n; ++i)
    {
        std::string s;
        std::cin >> s;
        a.push_back(s);
    }

    std::sort(a.begin(), a.end(),
        [](const std::string& lhs, const std::string& rhs)
        {
            if (lhs.size() != rhs.size())
            {
                return lhs.size() < rhs.size();
            }
            return lhs < rhs;
        });

    a.erase(std::unique(a.begin(), a.end()), a.end());

    for (const auto& s : a)
    {
        std::cout << s << '\n';
    }

    return 0;
}
```

---
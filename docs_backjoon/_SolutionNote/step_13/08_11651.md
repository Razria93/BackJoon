### 기본정보

| TITLE      | VALUE                                                                             |
| ---------- | --------------------------------------------------------------------------------- |
| **일시**     | 2026.02.10                                                                        |
| **번호**     | 11651                                                                             |
| **아이디어**   | N개의 좌표를 저장한 뒤, <br>람다 비교자를 사용해 **y 오름차순**, y가 같으면 **x 오름차순**으로 정렬, <br>이후 순서대로 출력 |
| **시간복잡도**  | O(N log N)                                                                        |
| **사용 API** | `std::vector`, `std::pair`, `reserve`, `push_back`, `std::sort`, 람다 Comparator    |
| **경과시간**   | 25분                                                                               |
| **결과**     | PASS                                                                              |
| 재풀이여부      | O                                                                                 |

---
### 메모

- `11651번`에서 이야기 했던 비교 함수를 기본값을 사용하지 않고 새로 제안해야하는 경우임

- `pair` 이기 때문에 1차적으로 첫번째 비교 값이 같은지 판별 후 알맞은 `return` 값을 반환

- `return` 값은 `lhs`가 먼저오는 조건이 `true`가 되도록 작성하면 됨
  
---
### GPT 피드백

- 정렬 기준( y 우선, tie-breaker로 x )이 11651 요구사항과 정확히 일치함
    
- `size_t N`을 사용했으니 루프 인덱스도 `size_t`로 통일한 점은 일관적임
    
- 출력 루프 `for (std::pair<int,int> a : A)`는 복사 발생 → `for (const auto& a : A)`가 더 적절함(정답 영향 없음)
    
- 입력이 음수가 가능하므로 좌표 타입은 `int`가 적절함(현재 `pair<int,int>` 사용 OK)

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;

    std::vector<std::pair<int, int>> a;
    a.reserve(n);

    for (int i = 0; i < n; ++i)
    {
        int x, y;
        std::cin >> x >> y;
        a.push_back({ x, y });
    }

    std::sort(a.begin(), a.end(),
        [](const auto& lhs, const auto& rhs)
        {
            if (lhs.second != rhs.second)
            {
                return lhs.second < rhs.second;
            }
            return lhs.first < rhs.first;
        });

    for (const auto& p : a)
    {
        std::cout << p.first << ' ' << p.second << '\n';
    }

    return 0;
}
```

---
### 기본정보

| TITLE      | VALUE                                                              |
| ---------- | ------------------------------------------------------------------ |
| **일시**     | 2026.02.10                                                         |
| **번호**     | 25305                                                              |
| **아이디어**   | N개 점수를 입력받아 <br>정렬로 커트라인을 계산<br>내림차순 기준 K번째 값(`A[K-1]`) 출력         |
| **시간복잡도**  | O(N log N)                                                         |
| **사용 API** | `std::vector`, `reserve`, `push_back`, `std::sort`, `std::reverse` |
| **경과시간**   | 5분                                                                 |
| **결과**     | PASS                                                               |
| 재풀이여부      | O                                                                  |

---
### 메모

- 알고리즘 구성은 맞았으나 내림차순 정렬로 정렬하는 방식이 불필요한 부분이 있었음

- 또한 최적해 방식으로 더 빠르게 해당 요소만 찾는 방법도 있으므로 재풀이 때 다르게 풀어보기
  
---
### GPT 피드백

- `std::sort` 후 `std::reverse` 대신 `std::sort(..., std::greater<>{})`로 내림차순 정렬을 한 번에 처리 가능
    
- “K번째 값”만 필요하면 `std::nth_element`로 평균 O(N)에 해결 가능(전체 정렬 불필요)
    
- `size_t`는 unsigned라 입력 범위/음수 가능성 있는 문제에서는 타입 선택에 주의 필요(이 문제는 점수라 큰 문제는 없음)

---
### 정석 코드 제안
#### 정석 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int N, K;
    std::cin >> N >> K;

    std::vector<int> A;
    A.reserve(N);

    for (int i = 0; i < N; ++i) 
    {
        int x;
        std::cin >> x;
        A.push_back(x);
    }

    std::sort(A.begin(), A.end(), std::greater<int>());

    std::cout << A[K - 1];
    return 0;
}
```

---
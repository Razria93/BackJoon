### 기본정보

| TITLE      | VALUE                                                                                                                                          |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| **일시**     | 2026.02.10                                                                                                                                     |
| **번호**     | 18870                                                                                                                                          |
| **아이디어**   | 좌표들을 `Cached`에 원본 순서로 저장하고, <br>복사본 `A`를 정렬 후 <br>`unique`로 중복 제거<br>중복 제거된 정렬 배열의 인덱스를 `unordered_map(value → rank)`로 매핑<br>원본 순서대로 `rank` 출력 |
| **시간복잡도**  | O(N log N) (정렬 지배)                                                                                                                             |
| **사용 API** | `std::vector`, `std::sort`, `std::unique`, `erase`, <br>`std::unordered_map`, `insert`, `find`                                                 |
| **경과시간**   | 40분                                                                                                                                            |
| **결과**     | PASS                                                                                                                                           |
| 재풀이여부      | O                                                                                                                                              |

---
### 메모

- 더 나은 풀이가 있으므로 해당 방식으로 재풀이 요망
  
---
### GPT 피드백

- 전형적인 **좌표 압축** 풀이로 정답 방향이 맞음
    
- `unordered_map`에 `insert({A[i], i})`는 키 중복이 없으니 문제 없지만, 스타일상 `M[A[i]] = i;`가 더 단순함(여기서는 중복 제거 후라 안전)
    
- `find` 결과를 바로 `f->second`로 쓰고 있는데, 이 문제에선 반드시 존재하므로 안전하지만, 일반적으로는 `f != M.end()` 체크가 필요함
    
- 루프 인덱스에서 `A.size()`/`Cached.size()`는 `size_t`라서 `int i`와 혼용 경고가 날 수 있음. 인덱스를 `size_t`로 맞추거나 `int n` 기준으로 통일하는 편이 깔끔함
    
- `A.reserve(N); Cached.reserve(N);`를 추가하면 재할당을 줄일 수 있음(성능 미세 개선)

---
### 정석 코드 제안
#### 정석 코드 (내 풀이 기준)
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;

    std::vector<int> original;
    std::vector<int> sorted;
    original.reserve(n);
    sorted.reserve(n);

    for (int i = 0; i < n; ++i)
    {
        int x;
        std::cin >> x;

        original.push_back(x);
        sorted.push_back(x);
    }

    std::sort(sorted.begin(), sorted.end());
    sorted.erase(std::unique(sorted.begin(), sorted.end()), sorted.end());

    std::unordered_map<int, int> rank;
    rank.reserve(static_cast<size_t>(sorted.size()) * 2);

    for (int i = 0; i < static_cast<int>(sorted.size()); ++i)
    {
        rank[sorted[i]] = i;
    }

    for (int i = 0; i < n; ++i)
    {
        std::cout << rank[original[i]] << ' ';
    }

    return 0;
}
```

#### 정석 코드 (`std::lower_bount` 사용)
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;

    std::vector<int> original;
    std::vector<int> sorted;

    original.reserve(n);
    sorted.reserve(n);

    for (int i = 0; i < n; ++i)
    {
        int x;
        std::cin >> x;

        original.push_back(x);
        sorted.push_back(x);
    }

    std::sort(sorted.begin(), sorted.end());
    sorted.erase(std::unique(sorted.begin(), sorted.end()), sorted.end());

    for (int i = 0; i < n; ++i)
    {
        auto it = std::lower_bound(sorted.begin(), sorted.end(), original[i]);
        int rank = static_cast<int>(it - sorted.begin());

        std::cout << rank << ' ';
    }

    return 0;
}
```

---
### 개념 설명

### `std::lower_bound`

- **좌표압축 핵심**
    
    - 정렬 + 중복제거된 배열 `sorted`는 **값의 순위표(rank)** 역할을 함
        
    - 어떤 값 `x`의 `rank`는 `sorted`에서 `x`가 위치한 **인덱스(오프셋)** 와 동일
        
- **lower_bound**
    
    - 정렬된 구간에서 **처음으로 `value` 이상(>= value)** 이 되는 위치를 반환
        
    - `sorted`에 `x`가 반드시 존재하면, 반환 iterator가 정확히 `x`를 가리킴
        
### `iterator`

#### 정의
컨테이너 **원소의 위치**를 가리키는 **포인터 유사 객체(핸들)**

#### 존재 이유
자료구조마다 내부 구조가 다르게 구현됨

- `vector`: 연속 배열
- `list`: 노드가 링크로 연결
- `set/map`: 트리 구조
- `unordered_map`: 해시 버킷 구조
    
C++은 “원소를 순회/검색/정렬” 같은 알고리즘을 **하나의 인터페이스** 사용하고자 하였으며,  
그 표준화 인터페이스가 **iterator**

#### 용도
표준 알고리즘(`sort`, `lower_bound`, `unique` 등)은 컨테이너 대신 **iterator 범위 `[begin, end)`** 를 받음

#### 특징
- `vector`는 **Random Access Iterator**를 제공하므로 iterator 뺄셈이 가능
	
	- `it - begin`은 **바이트 오프셋이 아니라 “원소 개수 단위 거리(distance)”**
	- 따라서 `it - sorted.begin()`은 곧 **0-based 인덱스**로 해석됨
		
- 반대로 `list`, `map` 같은 컨테이너는 iterator 뺄셈이 불가능(랜덤 접근 아님)

---